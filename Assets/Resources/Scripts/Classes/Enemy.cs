using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class Enemy : Person, IEnemyState {
    //isKinematic so need tranform.Position to move
    //float health 
    //Vector3 targetpos
    //navagent2d agent
    //boundaryscript boundary
    //audioclip audio1

    private List<GameObject> pathways = new List<GameObject>();
    private /*List<GameObject>*/ GameObject[] path; 
    private GameObject player;
    private SpriteRenderer displaysprite;
    private Sprite deadsprite;
    private float velocity;
    private float sightdistance;
    private int i;
    private bool isDead;
    private double randomvar;

    void Awake()
    {
        agent = gameObject.AddComponent<NavAgent2D>(); //creates accessor to NavAgent2D script
        boundary = gameObject.AddComponent<BoundaryScript>();
        displaysprite = gameObject.GetComponent<SpriteRenderer>();
        UpCollider = transform.FindChild("EnemyUpCollider").gameObject;
        DownCollider = transform.FindChild("EnemyDownCollider").gameObject;
        LeftCollider = transform.FindChild("EnemyLeftCollider").gameObject;
        RightCollider = transform.FindChild("EnemyRightCollider").gameObject; //colliders
        isDead = false;
        velocity = 1f;
        sightdistance = 4f;
        targetpos = new Vector3();
        i = 0;
        damage = 10;
        health = 50f;
    }
    // Use this for initialization
	void Start () {
        health = 10f;
        //deadsprite.name = "DeadSprite"; //get sprite named deadsprite
        randomvar = Random.value; //get random number
        player = GameObject.FindGameObjectWithTag("Player");
        DownCollider.SetActive(true);
        UpCollider.SetActive(false);
        LeftCollider.SetActive(false);
        RightCollider.SetActive(false);
        //Debug.Log(GameObject.FindGameObjectsWithTag("Path").ToString());
        /*pathways.AddRange(GameObject.FindGameObjectsWithTag("Path")); //collect paths
        Debug.Log(pathways); 
        for (int i = 0; i < pathways.Count; i++) //go through each path is pathways
        {
            if (randomvar >= i / pathways.Count && randomvar <= (i+ 1)/ pathways.Count) //if the random variable is between n/paths and n+1/paths 
            {
                foreach (Transform waypoint in pathways[i].transform) //set the path to those waypoints
                {
                    if (waypoint.tag == "Path")
                    {
                        path.Add(waypoint.gameObject);
                        //Debug.Log(waypoint.gameObject.ToString());
                    }
                }
            }
        }
        */
        //path.AddRange(GameObject.FindGameObjectsWithTag("Waypoint"));
        path = GameObject.FindGameObjectsWithTag("Waypoint");
    }
	
    void FixedUpdate()
    {
        boundary.CheckBoundaryFor("Enemy");
    }
	// Update is called once per frame
	void LateUpdate ()
    {
        UpdateState();
    }

    public bool getisDead()
    {
        return isDead;
    }

    public float getDamage()
    {
        return damage;
    }

    //functions from IEnemyState interface 
    public void Patrol() 
    {
            targetpos = path[i].transform.position; //set patrol
            if (transform.position == targetpos) //if enemy has reached the targetpos, then move to next one in array
            {
                i++;
                i = i % path.Length; //loop back 
            }
        StayInBounds();
        transform.position = Vector3.MoveTowards(transform.position, targetpos, Time.deltaTime * velocity); //move to targetpos
    }
    public void Attack()
    {
        targetpos = player.transform.position;
        StayInBounds();
        transform.position = Vector3.MoveTowards(transform.position, targetpos, Time.deltaTime * velocity);
        //agent.SetDestination(player.transform.position); //follow player
        //Debug.Log("Attack!");
    }
    public IEnumerator Dead() 
    {
        displaysprite.sprite = deadsprite; //display dead sprite
        yield return new WaitForSeconds(5);
        Destroy(this.gameObject);
    }
    public void UpdateState()
    {
        if (health <= 0)
        {
            Destroy(gameObject);
        }
        if (Vector3.Distance(transform.position, player.transform.position) >= sightdistance && isDead == false)
        {
            Patrol();
            UpdateSprite();
        }
        else if (isDead == false)
        {
            Attack();
            UpdateSprite();
        }
        else
        {
            StartCoroutine(Dead());
        }
        
    }

    public void StayInBounds()
    {
        if (boundary.getTopBoundary() == true)
        {
            //targetpos.y = boundary.getTopBoundary().point.y;
            targetpos.y = Mathf.Clamp(targetpos.y, 0, boundary.getTopBoundary().point.y);
        }
        if (boundary.getBottomBoundary() == true)
        {
           // targetpos.y = boundary.getTopBoundary().point.y;
            targetpos.y = Mathf.Clamp(targetpos.y, 0, boundary.getTopBoundary().point.y);
        }
        if (boundary.getLeftBoundary() == true)
        {
            //targetpos.x = boundary.getTopBoundary().point.x;
            targetpos.x = Mathf.Clamp(targetpos.x, 0, boundary.getTopBoundary().point.x);
        }
        if (boundary.getRightBoundary() == true)
        {
            //targetpos.x = boundary.getTopBoundary().point.x;
            targetpos.x = Mathf.Clamp(targetpos.x, 0, boundary.getTopBoundary().point.x);
        }
    }

    public void UpdateSprite()
    {
        if (Vector3.Angle(transform.position, targetpos) >= 315f && Vector3.Angle(transform.position, targetpos) < 45f) // (x) divided sprite rendering
        {
            RightCollider.SetActive(true);
            UpCollider.SetActive(false);
            LeftCollider.SetActive(false);
            DownCollider.SetActive(false);
        }
        else if (Vector3.Angle(transform.position, targetpos) >= 45f && Vector3.Angle(transform.position, targetpos) < 135f)
        {
            RightCollider.SetActive(false);
            UpCollider.SetActive(true);
            LeftCollider.SetActive(false);
            DownCollider.SetActive(false);
        }
        else if (Vector3.Angle(transform.position, targetpos) >= 135f && Vector3.Angle(transform.position, targetpos) < 225f)
        {
            RightCollider.SetActive(false);
            UpCollider.SetActive(false);
            LeftCollider.SetActive(true);
            DownCollider.SetActive(false);
        }
        else if (Vector3.Angle(transform.position, targetpos) >= 225f && Vector3.Angle(transform.position, targetpos) < 315f)
        {
            RightCollider.SetActive(true);
            UpCollider.SetActive(false);
            LeftCollider.SetActive(false);
            DownCollider.SetActive(false);
        }
    }
}
